var LakeListVM = function() {	var self = this;	this.setCurrentLake = function(theLake) {console.log("LakeListVM.setCurrentLake");		viewModel.setCurrentLake(theLake);	};	this.filteredLakes = ko.computed(function() {		var filtered = [];		viewModel.lakes().forEach(function(aLake) {			if ("" != aLake.area()) {				if (filtersVM.areaFilters()[aLake.area()]()) {					if (self.hasChosenSpecies(aLake)) {						filtered[filtered.length] = aLake;					};				};			};		});		return filtered;	});	this.hasChosenSpecies = function(theLake) {		if (0 < theLake.species().length) {			for (var i = 0; i < filtersVM.speciesFilters().length; i++) {				var sFilter = filtersVM.speciesFilters()[i];			//self.speciesFilters().some(function(sFilter) {//console.log("checking: " + sFilter().name() + " against " + theLake.name());				if (sFilter().value()) {					if (-1 != $.inArray(sFilter().name(), theLake.species())) {//console.log("  found!");						return true;					};				};				//return false;			};		};		return false;	};	this.loadLakeData = function() {		LakeData.forEach(function(aLake) {//console.log("loading:" + aLake.name);			var info = new LakeInfo(aLake.name, aLake.href);			info.county(aLake.county);			info.latlon(aLake.latlon);			info.area(aLake.area);			aLake.species.forEach(function(aSpecies) {				info.species.push(aSpecies);				//If not there already, add species to speciesFilters...				filtersVM.addSpeciesFilter(aSpecies);			});			mapVM.buildMarker(info);			viewModel.lakes.push(info);		});		filtersVM.setInitialSpeciesFilterThreshold(10);	};};